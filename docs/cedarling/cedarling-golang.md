---
tags:
  - cedarling
  - golang
---

# Golang bindings for Cedarling

Cedarling provides a Golang binding via [rust2go](). The binding exposes a Golang package named `cedarling_go` which provides an interface for Cedarling functions. In order for an application to use the functions exposed by the binding, it must be dynamically linked to the `cedarling_go` binary.

## Requirements

* Rust 1.63 or greater with cargo
```bash   
rustc --version
cargo --version
```

* Golang 1.20 or greater. 
```bash
go --version
```


## Building

If you are using pre-built binaries from the [Jans releases page](https://github.com/JanssenProject/jans/releases/latest), you can skip this step. Otherwise, follow these instructions to build from source.

* Clone the Jans repository:
  ```bash
  git clone --depth 1 https://github.com/JanssenProject/jans.git 
  ```

* Navigate to the Cedarling Go bindings directory:
  ```bash
  cd jans/jans-cedarling/bindings/cedarling_go
  ```

* Build the binding:
  ```bash
  cargo build --release -p cedarling_go
  ```

* Copy the built artifacts to your current working directory:
```bash
# Windows
cp target/release/cedarling_go.dll .
cp target/release/cedarling_go.dll.lib cedarling_go.lib

# Linux
cp target/release/libcedarling_go.so .

# macOS
cp target/release/libcedarling_go.dylib .
```

Run go test to ensure everything is working correctly:

```bash
go test .
```

### Building your Go application with dynamic linking

* Download the appropriate pre-built binary for your platform from the [Jans releases page](https://github.com/JanssenProject/jans/releases/latest) or build it from source as described above.

* You need to specify linker flags in your `main.go` file to link against the Cedarling library.
```go
// #cgo LDFLAGS: -L. -lcedarling_go
import "C"
```

And make sure that the Cedarling library files are located in the same directory as your main package.

* Add the Cedarling Go package to your Go application:
```bash
go get github.com/JanssenProject/jans/jans-cedarling/bindings/cedarling_go
```

* Build your application:
```bash
go build .
```

Run application to ensure it works correctly.

### Runtime notes

- On **Windows**, place the Rust artifacts (`cedarling_go.dll` and `cedarling_go.lib`) alongside the Go binary.
  - Files:
    - `cedarling_go.dll`
    - `cedarling_go.lib`
  - Windows make search in next directories:
    - The directory containing your Go executable (recommended location)
    - Windows system directories (e.g., `C:\Windows\System32`)
    - The `PATH` environment variable directories

- On **Linux**, add the library directory to `LD_LIBRARY_PATH`:
  - Files:
    - `libcedarling_go.so`
```sh
export LD_LIBRARY_PATH=$(pwd):$LD_LIBRARY_PATH
```

- On **MacOS**, add the library directory to `DYLD_LIBRARY_PATH` (not tested):
  - Files:
    - `libcedarling_go.dylib`
```sh
export DYLD_LIBRARY_PATH=$(pwd):$DYLD_LIBRARY_PATH
```

## Documentation

Autogenerated documentation is available on [pkg.go.dev](https://pkg.go.dev/github.com/JanssenProject/jans/jans-cedarling/bindings/cedarling_go).

## Usage

### Initialization

```go
import "github.com/JanssenProject/jans/jans-cedarling/bindings/cedarling_go"

// Example configuration (populate dynamically in production)
config := map[string]any{
    "CEDARLING_APPLICATION_NAME":   "MyApp",
    "CEDARLING_POLICY_STORE_ID":    "your-policy-store-id",
    "CEDARLING_USER_AUTHZ":         "enabled",
    "CEDARLING_WORKLOAD_AUTHZ":     "enabled",
    "CEDARLING_LOG_LEVEL":          "INFO",
    "CEDARLING_LOG_TYPE":           "std_out",
    "CEDARLING_POLICY_STORE_LOCAL_FN": "/path/to/policy-store.json",
}

instance, err := cedarling_go.NewCedarling(config)
if err != nil {
    panic(err)
}
```

### Token-Based Authorization

**1. Define the resource:**

```go
resource := cedarling_go.EntityData{
    EntityType: "Jans::Issue",
    ID:         "random_id",
    Payload: map[string]any{
        "org_id":  "some_long_id",
        "country": "US",
    },
}
```

**2. Define the action:**

```go
action := `Jans::Action::"Update"`
```

**3. Build the request with tokens:**

```go
request := cedarling_go.Request{
    Tokens: map[string]string{
        "access_token":   "your.jwt.token",
        "id_token":       "your.id.token",
        "userinfo_token": "your.userinfo.token",
    },
    Action:   action,
    Resource: resource,
}
```

**4. Authorize:**

```go
result, err := instance.Authorize(request)
if err != nil {
    // Handle error
}

if result.Decision {
    fmt.Println("Access granted")
} else {
    fmt.Println("Access denied")
}
```

### Custom Principal Authorization (Unsigned)

**1. Define principals:**

```go
principals := []cedarling_go.EntityData{
    {
        EntityType: "Jans::User",
        ID:         "random_id",
        Payload: map[string]any{
            "role":    []string{"admin"},
            "country": "US",
            "sub":     "random_sub",
        },
    },
}
```

**2. Build the request:**

```go
request := cedarling_go.RequestUnsigned{
    Principals: principals,
    Action:     `Jans::Action::"Update"`,
    Resource:   resource, // From previous example
}
```

**3. Authorize:**

```go
result, err := instance.AuthorizeUnsigned(request)
if err != nil {
    // Handle error
}
if result.Decision {
   fmt.Println("Access granted")
} else {
    fmt.Println("Access denied")
}
```

### Logging

Retrieve logs stored in memory:

```go
// Get all logs and clear the buffer
logs := instance.PopLogs()

// Get a specific log by ID
log := instance.GetLogById("log123")

// Get logs by tag (e.g., "info")
logs := instance.GetLogsByTag("info")
```