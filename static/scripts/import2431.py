#!/usr/bin/env python
"""import2431.py - Script to import the backup into Gluu Server 3.0.x

Usage: python import2431.py <path_to_backup_folder>
Example: python import2431.py /root/backup_24

This script imports the data from backup folder generated by export2431.py.
Read complete migration procedure at:
    https://www.gluu.org/docs/deployment/upgrading/
"""

import os
import os.path
import sys
import logging
import traceback
import shutil
import json
import re
import subprocess
import time
import datetime
import base64
import pyDes
import ldap
import shelve
import random
import string
import uuid

from pyDes import *

from distutils.dir_util import copy_tree
from ldif import LDIFParser, LDIFWriter
import ldap.modlist as modlist

from jsonmerge import merge

from ldifschema_utils import OpenDjSchema

ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)

# configure logging
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)-8s %(name)s %(message)s',
                    filename='import2431.log',
                    filemode='w')
console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter('%(levelname)-8s %(message)s')
console.setFormatter(formatter)
logging.getLogger('').addHandler(console)
logging.getLogger('jsonmerge').setLevel(logging.WARNING)

def progress_bar(t, n, act='', finished=None):

    if not t % 50:

        if finished:
            i = 40
        else:
            i = (t*1.0/(n)) /0.025    
        ft = '#' * int(round(i))
        ft = ft.ljust(40)
        sys.stdout.write("\r[{0}] {1}".format(ft,act))
        sys.stdout.flush()
    if finished:
        print

def getQuad():
    return str(uuid.uuid4())[:4].upper()

def getPW(size=12, chars=string.ascii_uppercase + string.digits + string.lowercase):
        return ''.join(random.choice(chars) for _ in range(size))

def obscure(data, encode_salt):
    engine = triple_des(encode_salt, ECB, pad=None, padmode=PAD_PKCS5)
    data = data.encode('ascii')
    en_data = engine.encrypt(data)
    return base64.b64encode(en_data)


class DBLDIF(LDIFParser):
    def __init__(self, ldif_file):
        LDIFParser.__init__(self, open(ldif_file,'rb'))
        db_file =  os.path.basename(ldif_file)
        sdb_file = os.path.join('/tmp', db_file+'.sdb')
        if os.path.exists(sdb_file):
            os.remove(sdb_file)
        #logging.info("\nDumping %s to shelve database" % ldif_file)
        self.sdb = shelve.open(sdb_file)

    def handle(self, dn, entry):
        self.sdb[str(dn)] = entry


class MyLDIF(LDIFParser):
    def __init__(self, input, output):
        LDIFParser.__init__(self, input)
        self.targetDN = None
        self.targetAttr = None
        self.targetEntry = None
        self.DNs = []
        self.lastDN = None
        self.lastEntry = None
        self.entries = []

    def getResults(self):
        return (self.targetDN, self.targetAttr)

    def getDNs(self):
        return self.DNs

    def getLastEntry(self):
        return self.lastEntry

    def handle(self, dn, entry):
        if self.targetDN is None:
            self.targetDN = dn
        self.lastDN = dn
        self.DNs.append(dn)
        self.entries.append(entry)
        self.lastEntry = entry
        if dn.lower().strip() == self.targetDN.lower().strip():
            self.targetEntry = entry
            if self.targetAttr in entry:
                self.targetAttr = entry[self.targetAttr]


class Migration(object):
    def __init__(self, backup):
        self.backupDir = backup
        self.ldifDir = os.path.join(backup, 'ldif')
        self.certsDir = os.path.join(backup, 'etc', 'certs')
        self.currentDir = os.path.dirname(os.path.realpath(__file__))
        self.workingDir = os.path.join(self.currentDir, 'migration')
        self.jettyDir = "/opt/gluu/jetty/"
        self.os_types = ['centos', 'redhat', 'fedora', 'ubuntu', 'debian']
        self.os = self.detect_os_type()
        self.service = "/usr/sbin/service"
        if self.os is 'centos':
            self.service = "/sbin/service"
        self.open_dj_conf_dir = '/opt/opendj/config/schema/'
        self.slapdConf = "/opt/symas/etc/openldap/slapd.conf"
        self.slapcat = "/opt/symas/bin/slapcat"
        self.slapadd = "/opt/symas/bin/slapadd"
        self.keytool = "/opt/jre/bin/keytool"
        self.key_store = "/opt/jre/jre/lib/security/cacerts"
        self.ldif_import = "/opt/opendj/bin/import-ldif"
        self.ldif_export = "/opt/opendj/bin/export-ldif"
        self.ldif_search = "/opt/opendj/bin/ldapsearch"
        self.ldif_modify = "/opt/opendj/bin/ldapmodify"
        self.ldapHost = "127.0.0.1"
        self.ldapPort = "1636"
        self.baseDn = "cn=directory manager,o=gluu"
        self.ldapPassword = None
        self.key = None
        self.oxAuthClientSecret = None
        self.idpDN = None
        self.encryptIdpJson = None

        self.ldapDataFile = "/opt/gluu/data/main_db/data.mdb"
        self.ldapSiteFile = "/opt/gluu/data/site_db/data.mdb"

        self.currentData = os.path.join(self.workingDir, 'current.ldif')
        self.o_gluu = os.path.join(self.workingDir, "o_gluu.ldif")
        self.processTempFile = os.path.join(self.workingDir, "temp.ldif")
        self.o_site_static = "/install/community-edition-setup/static/cache-refresh/o_site.ldif"
        self.o_site = os.path.join(self.workingDir, "o_site.ldif")
        self.attrs = 2000
        self.objclasses = 2000
        self.ldap_type = 'openldap'
        self.gluuSchemaDir = '/opt/gluu/schema/openldap/'
        self.backupVersion = 0
        self.setup_properties = 'backup_2431/setup.properties'
        self.customAttrs = []

    def slapdConfAdd(self):
        with open(self.slapdConf, 'a') as f:
            f.writelines("sizelimit -1")
            f.close

    def slapdConfremove(self):
        with open(self.slapdConf, 'a+') as f:
            lines = f.readlines()
            lines = lines[:-1]
            f.close

    def readFile(self, inFilePath):
        if not os.path.exists(inFilePath):
            logging.debug("Cannot read: %s. File does not exist.", inFilePath)
            return None

        inFilePathText = None
        try:
            f = open(inFilePath)
            inFilePathText = f.read()
            f.close
        except:
            logging.warning("Error reading %s", inFilePath)
            logging.debug(traceback.format_exc())

        return inFilePathText

    def walk_function(self, a, directory, files):
        for f in files:
            fn = "%s/%s" % (directory, f)
            targetFn = fn.replace(self.backupDir, '')
            if os.path.isdir(fn):
                if not os.path.exists(targetFn):
                    os.mkdir(targetFn)
            else:
                self.getOutput(['cp', fn, targetFn])

    def detect_os_type(self):
        distro_info = self.readFile('/etc/redhat-release')
        if distro_info is None:
            distro_info = self.readFile('/etc/os-release')
        if 'CentOS' in distro_info:
            return self.os_types[0]
        elif 'Red Hat' in distro_info:
            return self.os_types[1]
        elif 'Ubuntu' in distro_info:
            return self.os_types[3]
        elif 'Debian' in distro_info:
            return self.os_types[4]
        else:
            return self.choose_from_list(self.os_types, "Operating System")

    def verifyBackupData(self):
        if not os.path.exists(self.backupDir):
            logging.error("Backup folder %s doesn't exist! Quitting migration",
                          self.backupDir)
            sys.exit(1)
        if not os.path.exists(self.ldifDir):
            logging.error("Backup doesn't contain directory for LDIF data."
                          " Nothing to migrate. Quitting.")
            sys.exit(1)

    def setupWorkDirectory(self):
        if not os.path.exists(self.workingDir):
            os.mkdir(self.workingDir)
        else:
            # Clean the directory in case its already present
            shutil.rmtree(self.workingDir)
            os.mkdir(self.workingDir)

    def getOutput(self, args):
        try:
            logging.debug("Running command : %s" % " ".join(args))
            p = subprocess.Popen(args, stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE)
            output, error = p.communicate()
            if error and 'Certificate was added to keystore' not in error:
                logging.error(error)
            logging.debug(output)
            return output
        except:
            logging.error("Error running command : %s" % " ".join(args))
            logging.error(traceback.format_exc())
            sys.exit(1)

    def copyCertificates(self):
        # remove opendj.crt
        opendj_cert_file = os.path.join(self.backupDir, 'etc/certs/opendj.crt')
        if os.path.exists(opendj_cert_file):
            command = ['rm',opendj_cert_file]
            output = self.getOutput(command)

        logging.info("Copying the Certificates.")
        os.path.walk("%s/etc" % self.backupDir, self.walk_function, None)

        logging.info("Updating the CA Certs Keystore.")
        keys = ['httpd', 'idp-signing', 'idp-encryption', 'shibidp', 'asimba']
        if self.ldap_type == 'openldap':
            keys.append('openldap')
        hostname = self.getOutput(['hostname']).strip()
        # import all the keys into the keystore
        for key in keys:
            alias = "{0}_{1}".format(hostname, key)
            filename = os.path.join(self.certsDir, key + ".crt")
            if not os.path.isfile(filename):
                logging.debug("Missing file: %s", filename)
                continue  # skip the non-existant certs

            logging.debug('Deleting new %s', alias)
            result = self.getOutput(
                [self.keytool, '-delete', '-alias', alias, '-keystore',
                 self.key_store, '-storepass', 'changeit', '-noprompt'])
            logging.error(result) if 'error' in result else logging.debug('Delete operation success.')

            logging.debug('Importing old %s', alias)
            result = self.getOutput(
                [self.keytool, '-import', '-trustcacerts', '-file', filename,
                 '-alias', alias, '-keystore', self.key_store, '-storepass',
                 'changeit', '-noprompt'])
            logging.error(result) if 'error' in result else logging.debug('Certificate import success.')

    def stopSolserver(self):
        logging.info("Stopping OpenLDAP Server.")
        stop_msg = self.getOutput([self.service, 'solserver', 'stop'])
        output = self.getOutput([self.service, 'solserver', 'status'])
        if "is not running" in output:
            return
        else:
            logging.error("Couldn't stop the OpenLDAP server.")
            logging.error(stop_msg)
            sys.exit(1)

    def startSolserver(self):
        logging.info("Starting OpenLDAP Server.")
        start_msg = self.getOutput([self.service, 'solserver', 'start'])
        output = self.getOutput([self.service, 'solserver', 'status'])
        if "is running" in output:
            return
        else:
            logging.error("Couldn't start the OpenLDAP server.")
            logging.error(start_msg)
            sys.exit(1)

    def copyCustomFiles(self):
        logging.info("Copying the custom pages and assets of webapps.")
        folder_map = [(os.path.join(self.backupDir, 'opt'), '/opt')]

        if self.version < 300:
            custom = self.backupDir + '/var/gluu/webapps/'
            folder_map = [
                #(custom + 'oxauth/pages', self.jettyDir + 'oxauth/custom/pages'),  #MB: this may break gluu gui
                (custom + 'oxauth/resources', self.jettyDir + 'oxauth/custom/static'),
                (custom + 'oxauth/libs', self.jettyDir + 'oxauth/lib/ext'),
                #(custom + 'oxtrust/pages', self.jettyDir + 'identity/custom/pages'), #MB: this may break gluu gui
                (custom + 'oxtrust/resources', self.jettyDir + 'identity/custom/static'),
                (custom + 'oxtrust/libs', self.jettyDir + 'identity/lib/ext'),
            ]

        for pair in folder_map:
            if pair[1] == '/opt':
                continue
            logging.debug("Copying tree %s to %s", pair[0],  pair[1])
            copy_tree(pair[0], pair[1])

    def stopWebapps(self):
        logging.info("Stopping Webapps oxAuth and Identity.")
        stop_msg = self.getOutput([self.service, 'oxauth', 'stop'])
        status = self.getOutput([self.service, 'oxauth', 'status'])
        if 'Jetty NOT running' not in status:
            logging.error("Couldn't stop oxAuth.")
            logging.error(stop_msg)

        stop_msg = self.getOutput([self.service, 'identity', 'stop'])
        status = self.getOutput([self.service, 'identity', 'status'])
        if 'Jetty NOT running' not in status:
            logging.error("Couldn't stop Identity.")
            logging.error(stop_msg)

    def startWebapps(self):
        logging.info("Starting Webapps oxAuth and Identity.")
        start_msg = self.getOutput([self.service, 'oxauth', 'start'])
        status = self.getOutput([self.service, 'oxauth', 'status'])
        if 'Jetty running pid' not in status:
            logging.error("Couldn't stop oxAuth.")
            logging.error(start_msg)

        start_msg = self.getOutput([self.service, 'identity', 'start'])
        status = self.getOutput([self.service, 'identity', 'status'])
        if 'Jetty running pid' not in status:
            logging.error("Couldn't stop Identity.")
            logging.error(start_msg)

    def exportInstallData(self):
        self.stopLDAPServer()
        logging.info("Exporting LDAP data.")
        if self.ldap_type == 'openldap':
            output = self.getOutput([self.slapcat, '-f', self.slapdConf,
                                     '-l', self.currentData])
        elif self.ldap_type == 'opendj':
            output = self.getOutput(
                [self.ldif_export, '-n', 'userRoot', '-l', self.currentData])
        else:
            output = "No LDAP configured."
        logging.debug(output)

    def convertSchema(self, f):
        infile = open(f, 'r')
        output = ""

        atypeRegex = re.compile('^attributeTypes:\s', re.IGNORECASE)
        obclassRegex = re.compile('^objectClasses:\s', re.IGNORECASE)

        isOCcontinue = False

        for line in infile:
            if isOCcontinue:
                if line[-1:] == ')':
                    isOCcontinue = False
                else:
                    isOCcontinue = True
                continue
            line = line.replace("X-SCHEMA-FILE '100-user.ldif'",
                                "X-SCHEMA-FILE 'custom.schema'")
            line = line.replace("X-SCHEMA-FILE '99-user.ldif'",
                                "X-SCHEMA-FILE 'custom.schema'")
            line = line.replace("'gluu' )",
                                "'Gluu - custom person attribute' )")

            if re.match('^dn:', line) or re.match('^objectClass:', line) or \
                    re.match('^cn:', line):
                continue
            # empty lines and the comments are copied as such
            if re.match('^#', line) or re.match('^\s*$', line):
                pass
            elif re.match('^\s\s', line):  # change the space indent to tabs
                line = re.sub('^\s\s', '\t', line)
            elif re.match('^\s', line):
                line = re.sub('^\s', '\t', line)
            # Change the keyword for attributetype
            elif atypeRegex.match(line):
                line = atypeRegex.sub('\nattributetype ', line, 1)
                oid = 'oxAttribute:' + str(self.attrs + 1)
                oidregex = re.compile('\s[\d]+\s', re.IGNORECASE)
                line = oidregex.sub(' ' + oid + ' ', line, 1)
                self.attrs += 1
            # Change the keyword for objectclass
            elif obclassRegex.match(line):
                if 'SUP gluuPerson' in line and 'objectClass MAY' in line:
                    att = re.search(r'\((.*?)\)', line.split('objectClass MAY')[1]).group(1)
                    self.customAttrs.append(att)
                    continue
                elif 'SUP gluuPerson' in line and 'objectClass MUST' in line:
                    att = re.search(r'\((.*?)\)', line.split('objectClass MUST')[1]).group(1)
                    self.customAttrs.append(att)
                    continue
                else:
                    if line[-1:] == ')':
                        isOCcontinue = False
                    else:
                        isOCcontinue = True
                continue
            else:
                logging.debug("Skipping Line: {}".format(line.strip()))
                line = ""

            output += line

        infile.close()
        return output

    def updateUserSchema(self, infile, outfile):
        with open(infile, 'r') as olduser:
            with open(outfile, 'w') as newuser:
                for line in olduser:
                    if 'SUP top' in line:
                        line = line.replace('SUP top', 'SUP gluuPerson')
                    newuser.write(line)

    def collectAllSchemaInfo(self):
        result = { 'attributes': {}, 'objectclasses': {} }
        for sf in os.listdir(self.open_dj_conf_dir):
            sch = OpenDjSchema(os.path.join(self.open_dj_conf_dir, sf))
            for a in sch.attribute_names:
                result['attributes'][a] = sf
            for c in sch.class_names:
                result['objectclasses'][c] = sf
        return result


    def copyCustomSchema(self):
        logging.info("Checking Schema files for existance of Gluu attributes and classes")

        if self.ldap_type == 'opendj':

            attr_class = self.collectAllSchemaInfo()
            
            att_dict = {
                'gluuPermission': "( 1486403774573 NAME 'gluuPermission' EQUALITY caseIgnoreMatch ORDERING caseIgnoreOrderingMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 USAGE userApplications X-SCHEMA-FILE '100-user.ldif' X-ORIGIN 'gluu' )",
                'imapHost': "( 1486583290517 NAME 'imapHost' EQUALITY caseIgnoreMatch ORDERING caseIgnoreOrderingMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 USAGE userApplications X-SCHEMA-FILE '100-user.ldif' X-ORIGIN 'gluu' )",
                'imapUsername': "( 1486583381327 NAME 'imapUsername' EQUALITY caseIgnoreMatch ORDERING caseIgnoreOrderingMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 USAGE userApplications X-SCHEMA-FILE '100-user.ldif' X-ORIGIN 'gluu' )",
                'imapPort': "( 1486583426410 NAME 'imapPort' EQUALITY caseIgnoreMatch ORDERING caseIgnoreOrderingMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 USAGE userApplications X-SCHEMA-FILE '100-user.ldif' X-ORIGIN 'gluu' )",
                'imapPassword': "( 1486583480345 NAME 'imapPassword' EQUALITY caseIgnoreMatch ORDERING caseIgnoreOrderingMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 USAGE userApplications X-SCHEMA-FILE '100-user.ldif' X-ORIGIN 'gluu' )",
                'imapData': "( 1486583825530 NAME 'imapData' EQUALITY caseIgnoreMatch ORDERING caseIgnoreOrderingMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 USAGE userApplications X-SCHEMA-FILE '100-user.ldif' X-ORIGIN 'gluu' )",
                        }
            
            schema_77_old = OpenDjSchema(os.path.join(self.backupDir, 'opt/opendj/config/schema/77-customAttributes.ldif'))
            
            schema_77 = OpenDjSchema(os.path.join(self.open_dj_conf_dir,'77-customAttributes.ldif'))
            
            w = False

            for a in att_dict:
                if not a in attr_class['attributes']:
                    schema_77.add_attributes(att_dict[a])
                    w = True
                    
            for a in schema_77_old.attribute_names:
                if not a in attr_class['attributes']:
                    _attrib = schema_77_old.get_attribute_by_name(a)
                    schema_77.schema['attributeTypes'].append(_attrib)
                    w = True

            for c in schema_77_old.class_names:
                if not c in attr_class['objectclasses']:
                    _class = schema_77_old.get_class_by_name(c)
                    schema_77.schema['objectClasses'].append(_class)
                    w = True

            if w:
                schema_77.write()
                for a in att_dict:
                    attr_class['attributes'][a]='77-customAttributes.ldif'
            
            if 'gluuCustomPerson' not in attr_class['objectclasses']:
                schema_opendj = OpenDjSchema(os.path.join(self.open_dj_conf_dir,'100-user.ldif'))
                schema_opendj.add_classs("( 1.3.6.1.4.1.48710.1.4.101 NAME 'gluuCustomPerson' SUP top AUXILIARY MAY ( telephoneNumber $ mobile $ carLicense $ facsimileTelephoneNumber $ departmentNumber $ employeeType $ cn $ st $ manager $ street $ postOfficeBox $ employeeNumber $ preferredDeliveryMethod $ roomNumber $ secretary $ homePostalAddress $ l $ postalCode $ description $ title $ gluuPermission $ imapHost $ imapPort $ imapUsername $ imapPassword ) )")
                schema_opendj.write()
                attr_class['objectclasses']['gluuCustomPerson'] = '100-user.ldif'
            else:
                schema_opendj = OpenDjSchema(os.path.join(self.open_dj_conf_dir, attr_class['objectclasses']['gluuCustomPerson']))
                w = False
                gluuCustomPerson = schema_opendj.get_class_by_name('gluuCustomPerson')
                may_list = list(gluuCustomPerson.may)
                for a in ['imapHost', 'imapPort', 'imapUsername', 'imapPassword', 'gluuPermission']:
                    if a not in may_list:
                        may_list.append(a)
                        w = True
                if w:
                    gluuCustomPerson.may = tuple(may_list)
                    schema_opendj.write()
        
            #MB: add attribute oxSectorIdentifierURI to 101-ox.ldif
            
            schema_101 = OpenDjSchema(os.path.join(self.open_dj_conf_dir, '101-ox.ldif'))
            if not 'oxSectorIdentifierURI' in schema_101.attribute_names:
                schema_101.add_attribute(
                    oid='oxSectorIdentifierURI-oid',
                    names=['oxSectorIdentifierURI'],
                    syntax='1.3.6.1.4.1.1466.115.121.1.15',
                    origin='Gluu created attribute',
                    desc='ox Sector Identifier URI',
                    equality='caseIgnoreMatch',
                    substr='caseIgnoreSubstringsMatch',
                    )
                schema_101.add_attribute_to_class('pairwiseIdentifier', 'oxSectorIdentifierURI')
                schema_101.add_attribute_to_class('oxAuthUmaScopeDescription', 'oxUrl')
                schema_101.write()

            w = False
            for custom_schema in ['100-user.ldif','99-user.ldif']:

                schema_n_old_file = os.path.join(self.backupDir, 'opt/opendj/config/schema', custom_schema)
                if os.path.exists(schema_n_old_file):
                    schema_n_old = OpenDjSchema(schema_n_old_file)
                    
                    gluuCustomPerson = schema_77.get_class_by_name('gluuCustomPerson')
                    may_list = list(gluuCustomPerson.may)

                    for a in schema_n_old.attribute_names:
                        
                        if not a in attr_class['attributes']:
                            _attrib = schema_n_old.get_attribute_by_name(a)
                            schema_77.schema['attributeTypes'].append(_attrib)

                        if not a in may_list:
                            may_list.append(a)
                            w = True
                    if w:
                        gluuCustomPerson.may = tuple(may_list)
                        schema_77.write()

                    for c in schema_n_old.class_names:
                        if not c in attr_class['objectclasses']:
                            _class = schema_n_old.get_class_by_name(c)
                            schema_77.schema['objectClasses'].append(_class)
                            w = True

            if w:
                schema_77.write()

        #MB: I did not understand why we are doing followings

        """

        # Process for openldap and then append the contents to custom schema
        new_user = os.path.join(self.workingDir, 'new_99.ldif')
        custom_schema = os.path.join(self.gluuSchemaDir, 'custom.schema')
        output = ""

        if os.path.isfile(schema_99):
            output = self.convertSchema(schema_100)
            self.updateUserSchema(schema_99, new_user)
            output = output + "\n" + self.convertSchema(new_user)
        else:
            # If there is no 99-user file, then the schema def is in 100-user
            self.updateUserSchema(schema_100, new_user)
            output = self.convertSchema(new_user)

        outfile2 = open(os.path.join(self.gluuSchemaDir, 'custom.schema'), 'r')
        temp_schema = outfile2.read()
        custArrtributes = ''
        for indx, line in enumerate(self.customAttrs):
            custArrtributes = custArrtributes + ' $ ' + line
        if len(self.customAttrs) > 0:
            customAttrs = set(custArrtributes.split(' $ '))
        else:
            customAttrs = []
        custArrtributes = ""
        if len(self.customAttrs) > 0:
            for indx, line in enumerate(self.customAttrs):
                if indx == 0:
                    custArrtributes = custArrtributes + " $ " + line
                elif (indx < len(self.customAttrs) - 1):
                    custArrtributes = custArrtributes + line + " $ "
                else:
                    custArrtributes = custArrtributes + line
        print custArrtributes

        temp_schema = temp_schema.replace(
            re.search(r'\((.*?)\)', temp_schema.split('MAY')[1]).group(1),
            re.search(r'\((.*?)\)', temp_schema.split('MAY')[1]).group(1) + custArrtributes)
        outfile2.close()
        outfile = open(custom_schema, 'w')
        outfile.write(output + "\n" + temp_schema)
        outfile.close()

        eduperson = ""
        eduPath = os.path.join("/opt", "symas", "etc", "openldap", "schema", "eduperson.schema")
        input_file = open(eduPath)
        try:
            for i, line in enumerate(input_file):
                if i == 62:
                    line = line + "\n" + "attributetype ( 1.3.6.1.4.1.5923.1.1.1.9"
                    line = line + "\n" + "\t\tNAME 'eduPersonScopedAffiliation'"
                    line = line + "\n" + "\t\tDESC 'eduPerson per Internet2 and EDUCAUSE'"
                    line = line + "\n" + "\t\tEQUALITY caseIgnoreMatch"
                    line = line + "\n" + "\t\tSYNTAX '1.3.6.1.4.1.1466.115.121.1.15' SINGLE-VALUE )"
                    line = line + "\n"
                    line = line + "\n" + "attributetype ( 1.3.6.1.4.1.5923.1.1.1.10"
                    line = line + "\n" + "\t\tNAME 'eduPersonTargetedID'"
                    line = line + "\n" + "\t\tDESC 'eduPerson per Internet2 and EDUCAUSE'"
                    line = line + "\n" + "\t\tEQUALITY caseIgnoreMatch"
                    line = line + "\n" + "\t\tSYNTAX '1.3.6.1.4.1.1466.115.121.1.15' SINGLE-VALUE )"
                    line = line + "\n"
                    line = line + "\n" + "attributetype ( 1.3.6.1.4.1.5923.1.1.1.11"
                    line = line + "\n" + "\t\tNAME 'eduPersonAssurance'"
                    line = line + "\n" + "\t\tDESC 'eduPerson per Internet2 and EDUCAUSE'"
                    line = line + "\n" + "\t\tEQUALITY caseIgnoreMatch"
                    line = line + "\n" + "\t\tSYNTAX '1.3.6.1.4.1.1466.115.121.1.15' SINGLE-VALUE )"
                    line = line + "\n\n"
                if i == 63:
                    line = "\n" + line
                if i == 67:
                    line = line + "\t\teduPersonScopedAffiliation $ eduPersonTargetedID $ eduPersonAssurance $\n"
                eduperson = eduperson + line
        except Exception, e:
            logging.log(e)
        finally:
            input_file.close()
            f = open(eduPath, "w")
            f.write(eduperson)
        """
    def getEntry(self, fn, dn):
        parser = MyLDIF(open(fn, 'rb'), sys.stdout)
        parser.targetDN = dn
        parser.parse()
        return parser.targetEntry

    def getDns(self, fn):
        parser = MyLDIF(open(fn, 'rb'), sys.stdout)
        parser.parse()
        return parser.DNs

    def getOldEntryMap(self):
        logging.info("Preparing dn entry map")
        files = os.listdir(self.ldifDir)
        dnMap = {}

        # get the new admin DN
        admin_ldif = '/install/community-edition-setup/output/people.ldif'
        admin_dn = self.getDns(admin_ldif)[0]

        for fn in files:
            logging.info("Processing %s to create dn entry map" % fn)
            dnList = self.getDns(os.path.join(self.ldifDir, fn))
            for dn in dnList:
                # skip the entry of Admin DN
                if fn == 'people.ldif' and admin_dn in dn:
                    continue
                dnMap[dn] = fn

        return dnMap

    def convertTimeStamp(self, line):
        dateString = line.replace('oxAuthAuthenticationTime:', '').strip()
        try:
            dateTimestamp = time.mktime(time.strptime(dateString, "%a %b %d %H:%M:%S %Z %Y"))
            dateString = time.strftime("%Y%m%d%H%M%S", time.gmtime(dateTimestamp))
            ts = time.time()
            utc_offset = (datetime.datetime.fromtimestamp(ts) - datetime.datetime.utcfromtimestamp(ts)).total_seconds()
            dateString = "%s.%03dZ" % (
                time.strftime("%Y%m%d%H%M%S", time.localtime(dateTimestamp)), int(utc_offset // 60))
        except ValueError:
            # Data from OpenLDAP would already be in the expected format.
            # The above parsing would happen only for data from OpenDJ.
            pass
        return "%s: %s\n" % ('oxAuthAuthenticationTime', dateString)

    def convertRefreshLastUpdate(self, line):
        dateString = line.replace('gluuVdsCacheRefreshLastUpdate: ', '').strip()
        try:
            dateTimestamp = time.mktime(time.strptime(dateString, "%a %b %d %H:%M:%S %Z %Y"))
            dateString = time.strftime("%Y%m%d%H%M%S", time.gmtime(dateTimestamp))
            ts = time.time()
            utc_offset = (datetime.datetime.fromtimestamp(ts) - datetime.datetime.utcfromtimestamp(ts)).total_seconds()
            dateString = "%s.%03dZ" % (
                time.strftime("%Y%m%d%H%M%S", time.localtime(dateTimestamp)), int(utc_offset // 60))
        except ValueError:
            # Data from OpenLDAP would already be in the expected format.
            # The above parsing would happen only for data from OpenDJ.
            pass
        return "%s: %s\n" % ('gluuVdsCacheRefreshLastUpdate', dateString)

    def processBackupData(self):
        logging.info('Processing the LDIF data.')
        attrib_dn = "inum={0}!0005!D2E0,ou=attributes,o={0},o=gluu".format(self.inumOrg)
        
        ldif_shelve_dict = {}
        oxScripts = []
        
        # Determine current primary key
        
        appliences = MyLDIF(open(os.path.join(self.backupDir, 'ldif','appliance.ldif'), 'rb'), None)
        appliences.parse()
        
        for entry in appliences.entries:
            if 'oxIDPAuthentication' in entry:
                oxIDPAuthentication = json.loads(entry['oxIDPAuthentication'][0])
                idp_config = json.loads(oxIDPAuthentication['config'])
                primaryKey = idp_config['primaryKey']
                localPrimaryKey = idp_config['localPrimaryKey']

        processed_fp = open(self.processTempFile, 'w')
        ldif_writer = LDIFWriter(processed_fp,  
                                    base64_attrs=['gluuProfileConfiguration'])

        currentDNs = self.getDns(self.currentData)
        old_dn_map = self.getOldEntryMap()

        ignoreList = ['objectClass', 'ou', 'oxIDPAuthentication',
                      'gluuFreeMemory', 'gluuSystemUptime',
                      'oxLogViewerConfig', 'gluuLastUpdate']
        multivalueAttrs = ['oxTrustEmail', 'oxTrustPhoneValue', 'oxTrustImsValue',
                           'oxTrustPhotos', 'oxTrustAddresses', 'oxTrustRole',
                           'oxTrustEntitlements', 'oxTrustx509Certificate']

        if self.ldap_type == 'opendj':
            ignoreList.remove('oxIDPAuthentication')


        #First dump scripts.ldif, we need it to determine if gluuStatus of script is enabled
        sdb=DBLDIF(os.path.join(self.ldifDir, 'scripts.ldif'))
        sdb.parse()
        ldif_shelve_dict['scripts.ldif']=sdb.sdb

        script_replacements = {
                self.inumOrg + '!0011!2DAF.F995': self.inumOrg +'!0011!2DAF.F9A5'
            }

        enabled_scripts = []
        
        for dn in ldif_shelve_dict['scripts.ldif']:
            entry = ldif_shelve_dict['scripts.ldif'][dn]
            if ('gluuStatus' in entry) and (entry['gluuStatus'][0] == 'true'):
                inum = entry['inum'][0]
                enabled_scripts.append(script_replacements.get(inum, inum))


        # Rewriting all the new DNs in the new installation to ldif file
        nodn=len(currentDNs)
        for cnt, dn in enumerate(currentDNs):
            
            progress_bar(cnt, nodn, 'Rewriting DNs')
            new_entry = self.getEntry(self.currentData, dn)
    

            #If the script was previously enabled, eneble now
            if 'oxCustomScript' in new_entry['objectClass']:
                oxScripts.append(dn)
                if new_entry['inum'][0] in enabled_scripts:
                    logging.debug('Enabling script inum: %s' % new_entry['inum'][0])
                    new_entry['gluuStatus']=['true']


            if 'ou=appliances' in dn:
                if 'oxIDPAuthentication' in new_entry:
                    oxIDPAuthentication = json.loads(new_entry['oxIDPAuthentication'][0])
                    idp_config = json.loads(oxIDPAuthentication['config'])
                    idp_config['primaryKey'] = primaryKey
                    idp_config['localPrimaryKey'] = localPrimaryKey
                    oxIDPAuthentication['config'] = json.dumps(idp_config)
                    new_entry['oxIDPAuthentication'] = [ json.dumps(oxIDPAuthentication) ]

            if "o=site" in dn:
                continue  # skip all the o=site DNs

            if (dn not in old_dn_map) or (dn in oxScripts):
                
                ldif_writer.unparse(dn, new_entry)
                continue

            old_entry = self.getEntry(os.path.join(self.ldifDir, old_dn_map[dn]), dn)
            

            
            for attr in old_entry.keys():
   
                if attr in ignoreList:
                    continue
                
                if attr not in new_entry:
                    new_entry[attr] = old_entry[attr]
                elif old_entry[attr] != new_entry[attr]:
                    if len(old_entry[attr]) == 1:
                        try:
                            old_json = json.loads(old_entry[attr][0])
                            new_json = json.loads(new_entry[attr][0])
                            new_json = merge(new_json, old_json)
                            new_entry[attr] = [json.dumps(new_json)]
                        except:
                            if attr == 'oxScript':
                                new_entry[attr] = new_entry[attr]
                                logging.debug("Keeping new value for %s", attr)
                            else:
                                new_entry[attr] = old_entry[attr]
                                logging.debug("Keeping old value for %s", attr)
                    else:
                        new_entry[attr] = old_entry[attr]
                        logging.debug("Keep multiple old values for %s", attr)

            if 'oxAuthConfDynamic' in new_entry:
                oxAuthConfDynamic = json.loads(new_entry['oxAuthConfDynamic'][0])
                for endpoint in ('loginPage', 'authorizationPage', 'checkSessionIFrame'):
                    if not oxAuthConfDynamic[endpoint].endswith('.htm'):
                        oxAuthConfDynamic[endpoint] += '.htm'
                new_entry['oxAuthConfDynamic'][0] = json.dumps(oxAuthConfDynamic)            
            
            if 'oxIDPAuthentication'  in new_entry:
                oxIDPAuthentication = json.loads(new_entry['oxIDPAuthentication'][0])
                oxIDPAuthentication_config = json.loads(oxIDPAuthentication["config"])
                new_server_list = []
                
                for server in oxIDPAuthentication_config['servers']:
                    if server.startswith(self.hostname) or server.startswith(self.ip):
                        server = server.replace(self.hostname, 'localhost')
                    new_server_list.append(server)
                    
                oxIDPAuthentication_config['servers'] = new_server_list
                oxIDPAuthentication["config"] = json.dumps(oxIDPAuthentication_config)
                new_entry['oxIDPAuthentication'] = [ json.dumps(oxIDPAuthentication) ]

            

            if '314' >= self.oxVersion:
                if 'ou=oxauth,ou=configuration' in dn:
                    oxAuthConfDynamic = json.loads(new_entry['oxAuthConfDynamic'][0])
                    oxAuthConfDynamic['authorizationPage'] = 'https://{0}/oxauth/authorize.htm'.format(self.hostname)
                    oxAuthConfDynamic['loginPage'] = 'https://{0}/oxauth/login.htm'.format(self.hostname)
                    oxAuthConfDynamic['checkSessionIFrame'] = 'https://{0}/oxauth/opiframe.htm'.format(self.hostname)
                    new_entry['oxAuthConfDynamic'] = [json.dumps(oxAuthConfDynamic, indent=2)]

                    oxAuthConfStatic = json.loads(new_entry['oxAuthConfStatic'][0])
                    oxAuthConfStatic['baseDn']['metric'] = 'ou=statistic,o=metric'
                    new_entry['oxAuthConfStatic'] = [json.dumps(oxAuthConfStatic, indent=2)]

            ldif_writer.unparse(dn, new_entry)

        progress_bar(0, 0, 'Rewriting DNs', True)

        # Pick all the left out DNs from the old DN map and write them to the LDIF
        nodn = len(old_dn_map)
        
        
        for cnt, dn in enumerate(sorted(old_dn_map, key=len)):

            progress_bar(cnt, nodn, 'Perapring DNs for ' + self.oxVersion)
            if "o=site" in dn:
                continue  # skip all the o=site DNs
            if dn in currentDNs:
                continue  # Already processed

            cur_ldif_file = old_dn_map[dn]
            if not cur_ldif_file in ldif_shelve_dict:
                sdb=DBLDIF(os.path.join(self.ldifDir, cur_ldif_file))
                sdb.parse()
                ldif_shelve_dict[cur_ldif_file]=sdb.sdb

            entry = ldif_shelve_dict[cur_ldif_file][str(dn)]

            #Do not import guuStatus
            if ('gluuAttributeName' in entry) and ('gluuStatus' in entry['gluuAttributeName']):
                continue

            #Add client_credentials to oxAuthGrantType if client is custom client
            if 'oxAuthClient' in entry['objectClass']:
                inum = entry['inum'][0]
                inum_l = inum.split('!0008!')
                #custom clients has three quads
                if inum_l[1].count('.') > 2:
                    if entry['oxAuthGrantType'] and  not 'client_credentials' in entry['oxAuthGrantType']:
                        logging.debug('Adding client_credentials to oxAuthGrantType of client inum=%s', inum)
                        entry['oxAuthGrantType'].append('client_credentials')



            #MB: (1) TODO: instead of processing ldif twice, appy this method for (2)
            if 'ou=people' in dn:
                for o in entry['objectClass']:
                    if o.startswith('ox-'):
                        entry['objectClass'].remove(o)
                        entry['objectClass'].append('gluuCustomPerson')
                        break
            if 'ou=trustRelationships' in dn:
                if 'gluuIsFederation' in entry:
                    if entry['gluuIsFederation'][0] == 'true':
                        entry['gluuEntityType'] = ['Federation/Aggregate']

                    else:
                        entry['gluuEntityType'] = ['Single SP']    
                        entry['gluuSpecificRelyingPartyConfig']=['true']
                        LONGBASE64ENCODEDSTRING = '<rp:ProfileConfiguration xsi:type="saml:SAML2SSOProfile" \n\tincludeAttributeStatement="true"\n\tassertionLifetime="300000"\n\tassertionProxyCount="0"\n\tsignResponses="conditional"\n\tsignAssertions="never"\n\tsignRequests="conditional"\n\tencryptAssertions="conditional"\n\tencryptNameIds="never"\n/>'
                        entry['gluuProfileConfiguration']=[LONGBASE64ENCODEDSTRING]


            for attr in entry.keys():
                if attr not in multivalueAttrs:
                    continue  # skip conversion

                attr_values = []
                for val in entry[attr]:
                    json_value = None
                    try:
                        json_value = json.loads(val)
                        if type(json_value) is list:
                            attr_values.extend([json.dumps(v) for v in json_value])
                        else:
                            attr_values.append(val)
                    except:
                        logging.debug('Cannot parse multival %s in DN %s', attr, dn)
                        attr_values.append(val)
                entry[attr] = attr_values

            if 'oxAuthClientCustomAttributes' in entry['objectClass']:
                entry['objectClass'].remove('oxAuthClientCustomAttributes')

            if self.oxVersion >='3.1.3':
                sector_identifiers = 'ou=sector_identifiers,o={},o=gluu'.format(self.inumOrg)
                if dn == attrib_dn:
                    if 'oxAuthClaimName' in entry and not 'member_off' in entry['oxAuthClaimName']:
                        entry['oxAuthClaimName'].append('member_off')
                    else:
                        entry['oxAuthClaimName'] = ['member_off']

                if 'oxUmaResource' in entry['objectClass']:
                    if dn.startswith('inum'):
                        exploded_dn = ldap.dn.explode_dn(dn)
                        exploded_dn[0] = 'oxId=' + entry['oxId'][0]
                        exploded_dn[1] = 'ou=resources'
                        dn = ','.join(exploded_dn)
                        del entry['inum']


                if 'ou=clients' in dn:
                    if ('oxAuthGrantType' not in entry) or ('oxauthgranttype' not in entry):
                        entry['oxAuthGrantType'] = ['authorization_code']


            ldif_writer.unparse(dn, entry)

        # Finally
        processed_fp.close()

        progress_bar(0, 0, 'Perapring DNs for ' + self.oxVersion, True)
        
        #MB: (2) replace the following with above method
        # Update the Schema change for lastModifiedTime
        
        nodn = sum(1 for line in open(self.processTempFile))
        
        with open(self.processTempFile, 'r') as infile:
            with open(self.o_gluu, 'w') as outfile:
                
                for cnt, line in enumerate(infile):
                    progress_bar(cnt, nodn, 'converting Dns')
                    
                    line = line.replace("lastModifiedTime", "oxLastAccessTime")
                    line = line.replace('oxAuthUmaResourceSet', 'oxUmaResource')
                    if ("gluuAttributeOrigin:" in line and line.split("gluuAttributeOrigin: ")[1][:3] == 'ox-'):
                        line = 'gluuAttributeOrigin: gluuCustomPerson' + '\n'
                    if ("gluuAttributeOrigin:" in line and 'inetOrgPerson' in line):
                        line = 'gluuAttributeOrigin: gluuCustomPerson' + '\n'
                    if 'oxAuthAuthenticationTime' in line:
                        line = self.convertTimeStamp(line)
                    if 'oxAuthenticationMode' in line:
                        line = 'oxAuthenticationMode: auth_ldap_server' + '\n'
                    if 'oxTrustAuthenticationMode' in line:
                        line = 'oxTrustAuthenticationMode: auth_ldap_server'+ '\n'
                    #MB: See (1) how we implement this
                    #if ("objectClass:" in line and line.split("objectClass: ")[1][:3] == 'ox-'):
                    #    line = line.replace(line, 'objectClass: gluuCustomPerson' + '\n')
                    if 'oxType' not in line and 'gluuVdsCacheRefreshLastUpdate' not in line and 'objectClass: person' not in line and 'objectClass: organizationalPerson' not in line and 'objectClass: inetOrgPerson' not in line:
                        outfile.write(line)
                    # parser = MyLDIF(open(self.currentData, 'rb'), sys.stdout)
                    # atr = parser.parse()
                    base64Types = [""]
                    # for idx, val in enumerate(parser.entries):
                    # if 'displayName' in val:
                    #     if val['displayName'][0] == 'SCIM Resource Set':
                    #         out = CreateLDIF(parser.getDNs()[idx], val,
                    #                          base64_attrs=base64Types)
                    #         f = open(self.o_gluu, "a")
                    #         f.write('\n')
                    #         f.write(out)
        #data="".join(open( os.path.join(self.backupDir, 'ldif','site.ldif')).readlines()[4:-1])
        #open(os.path.join(self.backupDir, 'ldif','sitetmp.ldif'),"wb").write(data)
        #filenames = [self.o_site_static, os.path.join(self.backupDir, 'ldif','sitetmp.ldif')]
        #with open(self.o_site, 'w') as outfile:
        #    for fname in filenames:
        #        with open(fname) as infile:
        #            for line in infile:
        #                outfile.write(line)
        #os.remove(os.path.join(self.backupDir, 'ldif','sitetmp.ldif'))
        
        progress_bar(0, 0, 'converting Dns', True)
        
    def importDataIntoOpenldap(self):
        count = len(os.listdir('/opt/gluu/data/main_db/')) - 1
        backupfile = self.ldapDataFile + ".bkp_{0:02d}".format(count)
        logging.debug("Moving %s to %s.", self.ldapDataFile, backupfile)
        try:
            shutil.move(self.ldapDataFile, backupfile)
        except IOError:
            logging.debug(traceback.format_exc())

        count = len(os.listdir('/opt/gluu/data/site_db/')) - 1
        backupfile = self.ldapSiteFile + ".bkp_{0:02d}".format(count)
        logging.debug("Moving %s to %s.", self.ldapSiteFile, backupfile)
        try:
            shutil.move(self.ldapSiteFile, backupfile)
        except IOError:
            logging.debug(traceback.format_exc())

        output = self.getOutput([self.slapadd, '-c', '-b', 'o=gluu', '-f',
                                 self.slapdConf, '-l', self.o_gluu])
        logging.debug(output)
        output = self.getOutput([self.slapadd, '-c', '-b', 'o=site', '-f',
                                 self.slapdConf, '-l', self.o_site])
        logging.debug(output)

    def importDataIntoOpenDJ(self):
        command = [self.ldif_import, '-n', 'userRoot',
                   '-l', self.o_gluu, '-R', self.o_gluu + '.rejects']
        output = self.getOutput(command)
        logging.debug(output)

        command = [self.ldif_import, '-n', 'site',
                   '-l', self.o_site, '-R', self.o_site + '.rejects']
        output = self.getOutput(command)
        logging.debug(output)

    def importProcessedData(self):
        logging.info("Importing Processed LDAP data.")
        if self.ldap_type == 'openldap':
            self.importDataIntoOpenldap()
        else:
            self.importDataIntoOpenDJ()

    def getLDAPServerType(self):

        choice = 0
        if os.path.isfile(self.setup_properties):
            data = ""
            try:
                with open(self.setup_properties) as f:
                    for line in f:
                        if line == 'ldap_type=openldap\n':
                            choice = 1
                        elif line == 'ldap_type=opendj\n':
                            choice = 2
            except:
                logging.error(self.setup_properties+" File not Found")
                sys.exit(0)

        if choice == 1:
            self.ldap_type = 'openldap'
        elif choice == 2:
            self.ldap_type = 'opendj'
        else:
            logging.error("Invalid selection of LDAP Server. Cannot Migrate.")
            sys.exit(1)

    def stopOpenDJ(self):
        logging.info('Stopping OpenDJ Directory Server...')
        if (os.path.isfile('/usr/bin/systemctl')):
            self.getOutput(['systemctl', 'stop', 'opendj'])
            output = self.getOutput(['systemctl', 'is-active', 'opendj'])
        else:
            output = self.getOutput([self.service, 'opendj', 'stop'])

        if output.find("Directory Server is now stopped") > 0 or \
                        output.strip() == "failed":
            logging.info("Directory Server is now stopped")
        else:
            logging.error(
                "OpenDJ did not stop properly. Import cannot run without "
                "stopping the directory server. Exiting from import. Check"
                " /opt/opendj/logs/errors")
            sys.exit(1)

    def startOpenDJ(self):
        logging.info('Starting OpenDJ Directory Server...')
        if (os.path.isfile('/usr/bin/systemctl')):
            self.getOutput(['systemctl', 'start', 'opendj'])
            output = self.getOutput(['systemctl', 'is-active', 'opendj'])
            if output.find("Directory Server has started successfully") > 0 or \
                            output.strip() == "active":
                logging.info("Directory Server has started successfully")
        else:
            # start opendj through service
            output = self.getOutput([self.service, 'opendj', 'start'])
            if output != "":
                logging.error("OpenDJ did not start properly. Check "
                              "/opt/opendj/logs/errors. Restart it manually.")
                sys.exit(1)


    def stopLDAPServer(self):
        if self.ldap_type == 'openldap':
            self.stopSolserver()
        else:
            self.stopOpenDJ()

    def startLDAPServer(self):

        if self.ldap_type == 'openldap':
            self.startSolserver()
        else:
            self.startOpenDJ()

    def copyIDPFiles(self):
        logging.info('Copying Shibboleth IDP files...')

        dst = '/opt/shibboleth-idp'
        if os.path.isdir(dst):
            src = os.path.join(self.backupDir, 'opt', 'shibboleth-idp', 'metadata')
            if os.path.isdir(src):
                self.getOutput(['cp', '-r', src, dst])
            src = os.path.join(self.backupDir, 'opt', 'idp', 'metadata')
            if os.path.isdir(src):
                self.getOutput(['cp', '-r', src, dst])

        dst = '/opt/shibboleth-idp'
        src = os.path.join(self.backupDir, 'opt', 'idp', 'ssl')
        if os.path.isdir(dst) and os.path.isdir(src):
            self.getOutput(['cp', '-r', src, dst])


        ldap_properties_fn = '/opt/shibboleth-idp/conf/ldap.properties'
        
        if os.path.exists(ldap_properties_fn):

            if self.ldap_type == 'opendj':
                
                if os.path.exists(ldap_properties_fn):
                    tmp_fn = '/tmp/ldap.properties_file~'
                    out_file = open(tmp_fn,'w')
                    copy_file = False
                    
                    for l in open(ldap_properties_fn):
                        if l.startswith('idp.authn.LDAP.trustCertificates') and '/etc/certs/openldap.crt' in l:
                            l = l.replace('/etc/certs/openldap.crt', '/etc/certs/opendj.crt')
                            copy_file = True
                        out_file.write(l)

                    out_file.close()

                    if copy_file:
                        logging.info('Fixing Shibboleth IDP conf ...')
                        shutil.copy(tmp_fn, ldap_properties_fn)
                        self.getOutput(['chown', 'jetty:jetty', ldap_properties_fn])

                    os.remove(tmp_fn)

    def fixPermissions(self):
        logging.info('Fixing permissions for files.')
        if self.ldap_type == 'openldap':
            self.getOutput(['chown', 'ldap:ldap', self.ldapDataFile])
            self.getOutput(['chown', 'ldap:ldap', self.ldapSiteFile])
        else:
            self.getOutput(['chown', '-R', 'ldap:ldap', '/opt/opendj/db'])

        if os.path.exists(os.path.join('/opt','shibboleth-idp')):
            self.getOutput(['chown','-R','jetty:jetty',os.path.join('/opt','shibboleth-idp','metadata')])
            self.getOutput(['chown','-R','jetty:jetty',os.path.join('/opt','shibboleth-idp','conf')])

    def getProp(self, prop, prop_file=None):
        if not prop_file:
            prop_file = os.path.join(self.backupDir, 'setup.properties')

        with open(prop_file, 'r') as f:
            for line in f:
                n = line.find('=')
                if n > -1:
                    if line[:n]==prop:
                        tmp = line[n+1:].strip()
                        return tmp.replace('\\=','=')

    def unobscure(self,s=""):
        engine = pyDes.triple_des(self.key, pyDes.ECB, pad=None, padmode=pyDes.PAD_PKCS5)
        cipher = pyDes.triple_des(self.key)
        decrypted = cipher.decrypt(base64.b64decode(s), padmode=pyDes.PAD_PKCS5)
        return decrypted

    def getLdapPassword(self):

        try:
            with open('/etc/gluu/conf/ox-ldap.properties') as f:
                for line in f:
                    if line.startswith("bindPassword:"):
                        self.ldapPassword = line.split(":")[1].split("\n")[0].strip()

        except:
            logging.error("ox-ldap.properties file not Found")


        #get salt key
        saltFn = "/etc/gluu/conf/salt"
        try:
            f = open(saltFn)
            salt_property = f.read()
            f.close()
            self.key = salt_property.split("=")[1].strip()
            self.ldapPassword = self.unobscure(self.ldapPassword)
            #print self.ldapPassword

        except:
            logging.error("Salt key Access Error")


    def idpResolved(self):

        logging.info('Idp Configuration Setting...')
        self.getLdapPassword()

        if self.ldap_type == 'opendj':
            self.baseDn = "cn=directory manager"

        self.oxAuthClientSecret = self.getProp('oxauthClient_encoded_pw',self.setup_properties_last)
        oxauth_client_id = self.getProp('oxauth_client_id', self.setup_properties_last)
        inumAppliance = self.getProp('inumAppliance', self.setup_properties_last)
        
        con = ldap.initialize('ldaps://{}:{}'.format(self.ldapHost, self.ldapPort))
        con.simple_bind_s(self.baseDn, self.ldapPassword)

        dn = 'inum={},ou=clients,o={},o=gluu'.format(oxauth_client_id, self.inumOrg)
        
        con.modify_s(dn, [( ldap.MOD_REPLACE, 'oxAuthClientSecret', self.oxAuthClientSecret)])
        
        dn = 'ou=oxtrust,ou=configuration,inum={},ou=appliances,o=gluu'.format(inumAppliance)

        results = con.search_s(dn,  ldap.SCOPE_BASE, attrlist=['oxTrustConfApplication', 'oxTrustConfCacheRefresh'])

        jsons = results[0][1]['oxTrustConfApplication'][0]
        jdata = json.loads(jsons)
        jdata['oxAuthClientPassword']= self.oxAuthClientSecret
        jsons = json.dumps(jdata)

        con.modify_s(dn, [( ldap.MOD_REPLACE, 'oxTrustConfApplication',  jsons)])
        
        # CR bindDN = cn=directory manager set opendj time
        if self.ldap_type == 'opendj':
            jsons = results[0][1]['oxTrustConfCacheRefresh'][0]
            jdata = json.loads(jsons)
            jdata['inumConfig']['bindDN'] = 'cn=directory manager'
            jsons = json.dumps(jdata)
            con.modify_s(dn, [( ldap.MOD_REPLACE, 'oxTrustConfCacheRefresh',  jsons)])

        command = ['cp','/etc/certs/shibIDP.crt','/etc/certs/idp-signing.crt']
        output = self.getOutput(command)

        command = ['cp','/etc/certs/shibIDP.key','/etc/certs/idp-signing.key']
        output = self.getOutput(command)


        # Delete inum=None IDP client if exists
        dn = 'ou=clients,o={0},o=gluu'.format(self.inumOrg)
        result = con.search_s(dn, ldap.SCOPE_SUBTREE,'(&(objectClass=oxAuthClient)(displayName=IDP client))',['inum'])
        if result:
            if result[0][1]['inum'][0] == 'None':
                dn = result[0][0]
                con.delete_s(dn)
                logging.info('Idp Client with inum=None deleted.')

        #Create Client for IDP

        

        
        idp_client_id = self.getProp('idp_client_id', self.setup_properties_last)

        if not idp_client_id:
            clientTwoQuads = '%s.%s' % (getQuad(), getQuad())
            logging.info('Idp Client does not exist. Creating ...')
            idp_client_id = '%s!0008!%s' % (self.inumOrg, clientTwoQuads)

            dn = "inum={0},ou=clients,o={1},o=gluu".format(idp_client_id, self.inumOrg)
            
            idpClient_pw = getPW()
            
            encode_salt = self.getProp('encode_salt', self.setup_properties_last)
            idpClient_encoded_pw = obscure(idpClient_pw, encode_salt)

            attrs = { 'objectClass': ['oxAuthClient', 'top'],
                      'displayName': ['IDP client'],
                      'inum': [idp_client_id],
                      'oxAuthClientSecret': [idpClient_encoded_pw],
                      'oxAuthAppType': ['web'],
                      'oxAuthResponseType': ['code'],
                      'oxAuthGrantType': ['authorization_code','refresh_token'],
                      'oxAuthScope': [ 'inum={0}!0009!F0C4,ou=scopes,o={0},o=gluu'.format(self.inumOrg),
                                       'inum={0}!0009!10B2,ou=scopes,o={0},o=gluu'.format(self.inumOrg),
                                       'inum={0}!0009!764C,ou=scopes,o={0},o=gluu'.format(self.inumOrg),
                                    ],
                      'oxAuthRedirectURI': ['https://{0}/idp/Authn/oxAuth'.format(self.hostname)],
                      'oxAuthPostLogoutRedirectURI': ['https://{0}/idp/profile/Logout'.format(self.hostname)],
                      'oxAuthPostLogoutRedirectURI': ['https://{0}/identity/authentication/finishlogout'.format(self.hostname)],
                      'oxAuthLogoutURI': ['https://{0}/identity/logout'.format(self.hostname)],
                      'oxAuthTokenEndpointAuthMethod': ['client_secret_basic'],
                      'oxAuthIdTokenSignedResponseAlg': ['HS256'],
                      'oxAuthTrustedClient': ['true'],
                      'oxAuthSubjectType': ['public'],
                      'oxPersistClientAuthorizations': ['false'],
                      'oxAuthLogoutSessionRequired': ['true'],
                      }

            ldif = modlist.addModlist(attrs)
            con.add_s(dn,ldif)

            with open('/install/community-edition-setup/setup.properties.last','a') as W:
                W.write('idp_client_id=' + idp_client_id+'\n')
                W.write('idpClient_pw=' + idpClient_pw+'\n')
                W.write('idpClient_encoded_pw=' + idpClient_encoded_pw+'\n')

            logging.info('Idp client added')

        else:
            dn = "inum={0},ou=clients,o={1},o=gluu".format(idp_client_id, self.inumOrg)
            result = con.search_s(dn, ldap.SCOPE_BASE,'(objectClass=*)')
            idpClient_encoded_pw = result[0][1]['oxAuthClientSecret'][0]
            if not 'oxAuthLogoutURI' in result[0][1]:
                con.modify_s(dn, [( ldap.MOD_ADD, 'oxAuthLogoutURI', ['https://{0}/identity/logout'.format(self.hostname)])])
                logging.info('oxAuthLogoutURI was added for Idp client') 


        #Fix oxIDP for SAML
        dn = 'ou=oxidp,ou=configuration,inum={0},ou=appliances,o=gluu'.format(inumAppliance)        
        result = con.search_s(dn, ldap.SCOPE_BASE,'(objectClass=*)')
        oxConfApplication = json.loads(result[0][1]['oxConfApplication'][0])
        oxConfApplication['openIdClientId'] = idp_client_id
        oxConfApplication['openIdClientPassword'] = idpClient_encoded_pw
        
        oxConfApplication['openIdRedirectUrl'] = 'https://{0}/idp/Authn/oxAuth'.format(self.hostname)
        oxConfApplication['openIdPostLogoutRedirectUri'] = 'https://{0}/idp/profile/Logout'.format(self.hostname)
        oxConfApplication_js = json.dumps(oxConfApplication)
        con.modify_s(dn, [( ldap.MOD_REPLACE, 'oxConfApplication',  oxConfApplication_js)])
        logging.info('oxConfApplication was fixed for SAML') 



    def migrate(self):
        """Main function for the migration of backup data
        """
        print("\n")
        print("------------------------------------------------------------")
        print("        Gluu Server Community Edition Migration Tool        ")
        print("============================================================")
        
        self.setup_properties_last = '/install/community-edition-setup/setup.properties.last'
        self.version = int(self.getProp('version').replace('.', '')[0:3])
        self.inumOrg = self.getProp('inumOrg', self.setup_properties_last)
        self.oxVersion = self.getProp('oxVersion', self.setup_properties_last)
        self.hostname = self.getProp('hostname', self.setup_properties_last)
        self.ip = self.getProp('ip', self.setup_properties_last)
        self.oxVersion_number = self.oxVersion.replace('.', '').replace('Final','')


        self.getLDAPServerType()
        self.verifyBackupData()
        self.setupWorkDirectory()
        self.stopWebapps()
        self.copyCertificates()
        self.copyCustomFiles()
        self.copyIDPFiles()
        
        if self.version < 300 or self.ldap_type == 'opendj':
            self.copyCustomSchema()
            
        self.exportInstallData()
        self.processBackupData()
        self.importProcessedData()
        self.fixPermissions()
        self.startLDAPServer()
        self.idpResolved()

        print("============================================================")
        print("The migration is complete. Gluu Server needs to be restarted.")
        print("\n\n\t# logout\n\t# service gluu-server-x.x.x restart\n")
        print("------------------------------------------------------------")
        print("\n")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print "Usage: ./import2431.py <path_to_backup_folder>"
        print "Example:\n ./import2431.py /root/backup_2431"
    else:
        migrator = Migration(sys.argv[1])
        migrator.migrate()

